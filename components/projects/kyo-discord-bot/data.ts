export const kyoDiscordBotData = {
  title: 'Kyo Discord Bot',
  description: 'A powerful Discord bot built with TypeScript, featuring Supabase as the backend/database and hosted on Digital Ocean.',
  tech: ['TypeScript', 'Supabase', 'Digital Ocean'],
  image: '/images/kyoPfp.png',
  stats: {
    shard: '0 - Current',
    latency: '38ms',
    uptime: '14d 22h 26m 41s',
    ram: '2029.2 MB',
    cpu: '30.00%',
    servers: '722',
    members: '254,906',
  },
  architecture: {
    tldr: {
      overview: 'Production Discord bot serving 700+ servers and 250k+ members. Designed as a modular, event-driven system with horizontal sharding, multi-layer caching, and graceful degradation to ensure low-latency responses and high availability under load.',
      coreFlow: 'Discord API → Event Handlers → Middleware (permissions, rate limiting) → Command & Module Logic → Cache → Redis → PostgreSQL (source of truth)',
      keyDecisions: [
        'Sharding for horizontal scalability across guilds',
        'Multi-layer caching (in-memory + Redis) to reduce database load',
        'Modular architecture to isolate features and failures',
        'Graceful degradation to keep the system operational during partial outages',
      ],
      scalingReliability: [
        'Scales horizontally via Discord sharding',
        'Stateless command handling where possible',
        'Aggressive caching on read-heavy paths',
        'Fallbacks for cache, database, and external APIs',
      ],
      whyItMatters: 'This architecture prioritizes resilience and performance over perfect consistency, allowing the system to continue operating under failure while serving real-time user traffic at scale.',
    },
    details: {
      designDecisions: [
        {
          title: 'Sharding Support',
          decision: 'Sharding is used to handle a large number of guilds, providing horizontal scalability by distributing the workload.',
          tradeoff: 'Introduces complexity in managing multiple instances, but the benefit is seamless scaling as the bot\'s user base grows.',
        },
        {
          title: 'Caching Strategy',
          decision: 'In-Memory Cache (TTL: 120s) for frequently accessed data. Redis Cache (TTL: 300s) shared across shards. PostgreSQL as persistent storage and source of truth.',
          tradeoff: 'Reduces load on the database, but consistency issues can arise if caches fall out of sync (handled via TTL and event-based invalidation).',
        },
        {
          title: 'Event-Driven Design',
          decision: 'The bot processes real-time events via WebSockets (Discord Gateway), separating event handling from business logic.',
          tradeoff: 'More complex flow but ensures responsiveness and decouples components for easier maintenance.',
        },
        {
          title: 'External Services Integration',
          decision: 'Spotify, YouTube, Steam, etc. used for commands like music playback or external data fetching.',
          tradeoff: 'These dependencies add external failure points but allow richer functionality and features.',
        },
      ],
      dataFlow: 'User Input → Discord Gateway → Event Handler → Middleware → Command Handler → Cache → Database → External APIs → Response',
      scalingStrategy: [
        'Horizontal Scaling: Sharding configured via robo.mjs with stateless design, ensuring the bot can handle increasing traffic by adding more shards.',
        'Database Scaling: Read replicas for read-heavy operations. Connection pooling with PgBouncer for efficient DB connection management.',
        'Resource Management: Efficient memory use with TTL-based cache expiration. Connection pooling prevents excessive connection attempts under load.',
      ],
      failureHandling: [
        'Network, Database, and API Errors: Handled gracefully by fallback mechanisms (e.g., if Redis fails, fall back to database).',
        'Discord API Rate Limiting: Managed with exponential backoff and user feedback on limits.',
        'Graceful Degradation: If external services fail, the bot degrades by switching to alternative services or returning cached results.',
        'Cache Misses: If Redis fails, the system uses in-memory caches or directly queries the database.',
      ],
      performanceOptimizations: [
        'Cooldown Management: In-memory set operations prevent spam and ensure smooth user experience.',
        'Lazy Loading: Modules like Music, Levels, and Tickets are loaded on demand, reducing memory usage.',
        'Batch Database Queries: Bulk inserts and queries to minimize DB load and improve response time.',
        'Error Suppression: Non-critical errors are silently handled to avoid flooding the logs and maintain bot stability.',
      ],
      monitoring: [
        'Health Checks: Connection status for Redis, PostgreSQL, and external APIs are monitored continuously.',
        'Error Tracking: Network, database, and API errors are tracked, with different logging levels (info, warn, error).',
        'Threshold-based Alerts: Alerts triggered for issues like high latency, DB connection errors, or API failures.',
      ],
    },
    designDecisions: [
      {
        title: 'Sharding Support',
        decision: 'Sharding is used to handle a large number of guilds, providing horizontal scalability by distributing the workload.',
        tradeoff: 'Introduces complexity in managing multiple instances, but the benefit is seamless scaling as the bot\'s user base grows.',
      },
      {
        title: 'Caching Strategy',
        decision: 'In-Memory Cache (TTL: 120s) for frequently accessed data. Redis Cache (TTL: 300s) shared across shards. PostgreSQL as persistent storage and source of truth.',
        tradeoff: 'Reduces load on the database, but consistency issues can arise if caches fall out of sync (handled via TTL and event-based invalidation).',
      },
      {
        title: 'Event-Driven Design',
        decision: 'The bot processes real-time events via WebSockets (Discord Gateway), separating event handling from business logic.',
        tradeoff: 'More complex flow but ensures responsiveness and decouples components for easier maintenance.',
      },
      {
        title: 'External Services Integration',
        decision: 'Spotify, YouTube, Steam, etc. used for commands like music playback or external data fetching.',
        tradeoff: 'These dependencies add external failure points but allow richer functionality and features.',
      },
    ],
    dataFlow: 'User Input → Discord Gateway → Event Handler → Middleware → Command Handler → Cache → Database → External APIs → Response',
    scalingStrategy: [
      'Horizontal Scaling: Sharding configured via robo.mjs with stateless design, ensuring the bot can handle increasing traffic by adding more shards.',
      'Database Scaling: Read replicas for read-heavy operations. Connection pooling with PgBouncer for efficient DB connection management.',
      'Resource Management: Efficient memory use with TTL-based cache expiration. Connection pooling prevents excessive connection attempts under load.',
    ],
    failureHandling: [
      'Network, Database, and API Errors: Handled gracefully by fallback mechanisms (e.g., if Redis fails, fall back to database).',
      'Discord API Rate Limiting: Managed with exponential backoff and user feedback on limits.',
      'Graceful Degradation: If external services fail, the bot degrades by switching to alternative services or returning cached results.',
      'Cache Misses: If Redis fails, the system uses in-memory caches or directly queries the database.',
    ],
    performanceOptimizations: [
      'Cooldown Management: In-memory set operations prevent spam and ensure smooth user experience.',
      'Lazy Loading: Modules like Music, Levels, and Tickets are loaded on demand, reducing memory usage.',
      'Batch Database Queries: Bulk inserts and queries to minimize DB load and improve response time.',
      'Error Suppression: Non-critical errors are silently handled to avoid flooding the logs and maintain bot stability.',
    ],
    monitoring: [
      'Health Checks: Connection status for Redis, PostgreSQL, and external APIs are monitored continuously.',
      'Error Tracking: Network, database, and API errors are tracked, with different logging levels (info, warn, error).',
      'Threshold-based Alerts: Alerts triggered for issues like high latency, DB connection errors, or API failures.',
    ],
    conclusion: 'This architecture supports a modular, scalable, and fault-tolerant design suitable for production environments. Key strengths: Resilience (multiple fallback mechanisms), Performance (aggressive caching strategy), Scalability (horizontal sharding and connection pooling), and Reliability (robust failure handling and proactive monitoring).',
  },
  features: {
    'Core Infrastructure': [
      'Dual command system (Slash & Prefix)',
      'TypeScript codebase',
      'PostgreSQL & Supabase integration',
      'Redis caching layer',
      'Rate-limited error tracking',
      'Modular architecture',
      'Dynamic command registry',
    ],
    'Ticket System': [
      'Private thread tickets',
      'Auto-close (2hr inactivity)',
      'Button-based ticket panel',
      'Configurable support roles',
      'Multi-staff support',
      'Ticket management (join/leave/claim/close)',
      'Event logging & notifications',
    ],
    'Music System': [
      'RainLink integration',
      'Spotify & YouTube support',
      'Queue management',
      'Rich now playing embeds',
      'Vote to skip',
      'Role-based access control',
    ],
    'Leveling System': [
      'Message-based XP tracking',
      'Customizable XP requirements',
      'Server-wide leaderboards',
      'Rank cards with progress',
      'Automatic role rewards',
      'Channel/role blacklisting',
    ],
    'Integrations': [
      'Valorant (stats, MMR, matches)',
      'Sports (NBA, Soccer, ESPN)',
      'Steam profile lookup',
      'Instagram content',
      'LastFM scrobbling',
      'Crypto price tracking',
      'Google search & translate',
      'Urban Dictionary, Anime (MAL)',
    ],
    'Information & Utilities': [
      'User info (avatar, banner, stats)',
      'Server statistics',
      'Discord status',
      'Color extraction & OCR',
      'Timezone utilities',
      'Birthday tracking',
      'Message snipe',
      'AFK system',
    ],
    'Additional Systems': [
      'Event logging system',
      'Boost role management',
      'Vanity roles (custom status)',
      'Welcome messages',
      'Ping on join notifications',
      'Automated server setup',
      'Module & command toggling',
      'Permission & cooldown systems',
    ],
  },
};

